#! /usr/bin/env perl

use 5.10.0;
use strict;
use Error qw(:try);
use Error::Simple;
use Getopt::Long qw(:config no_ignore_case);
use Time::HiRes qw(time);

my $usage = "Directed Acyclic Graph Traverser Options:

Required:
    --input,-i      <path>          Sets the DAG input file.

Optional:
    --runs,-r       <integer>       Sets the total number of test runs of DFS on the DAG.
    --recursive,-R                  Uses the recursive depth first search algorithm.
    --bottomup,-b                   Uses the recursive depth first search algorithm.
    --dot,-d                        Generates Dot output using the pattern <input>.<integer>.dot.
    --help                          Display this message.

Example Usage:

    perl traverse --input example.dag --runs 5

";

my %OPT;
try {
    GetOptions(
        "input=s" => \$OPT{input},
        "runs=s" => \$OPT{runs},
        "r=s" => \$OPT{runs},
        "recursive" => \$OPT{recurse},
        "R" => \$OPT{recurse},
        "dot" => \$OPT{dot},
        "bottomup" => \$OPT{bottomup},
        "help|?" => sub { print $usage; exit(0); },
    );
}
catch Error::Simple with {
    my $E = shift;
    print STDERR $E->{-text};
    die "Failed to parse command line options.\n";
};

my $input = $OPT{input};
my $runs = $OPT{runs};
my $recurse = $OPT{recurse};
my $bottomup = $OPT{bottomup};
my $dot = $OPT{dot};
my $err = 0;

if(!$input) { print(STDERR "Missing --input option.\n"); $err++; }
if($err) {
    print(STDERR "Could not find $err required arguments.\n");
    print_help();
}

my %nodes;
my $nacc = 0;
my $eacc = 0;
my $par = 0;
my @errors;
my %mintree;
open(INPUT, $input) or die "Could not open DAG file for parsing.\n";
while(my $line = <INPUT>) {
    #N11 <- 9:10; -> -2:-2; <= TEST=1; => TEST=-1; != 0;
    if($line =~ m/N(?<nid>\d+)\s<-\s(?<par>([0-9:\-]+)?);\s->\s(?<child>([0-9:\-]+)?);\s=>\s(?<attr>.+);\s!=\s(?<err>\d+);\s+/) {
        my $nid = $+{nid};
        if(exists($mintree{$nid}) or $+{err}) {
            if($nodes{$nid}) {
                print(STDERR "Exception Raised: Node ($nid) already exists. Cannot replace it with duplicate node.\n");
                exit(1);
            }
            if($+{err}) { push(@errors, $nid); }

            my @children = split(":", $+{child});
            my @parents = split(":", $+{par});
            foreach my $p (@parents) {
                $mintree{$p} = 1;
            }
            my %node;
            $node{'n'} = $+{nid};
            $node{'c'} = $+{child};
            $node{'a'} = $+{attr};
            $node{'p'} = $+{par};
            $node{'e'} = $+{err};
            $node{'v'} = 0;
            $nodes{$nid} = \%node;

            $nacc++;
            foreach my $c (@children) {
                $eacc++;
            }
        }
    }
}
close(INPUT);
undef(%mintree);

print(STDERR "Graph generated in-memory. Traversing graph.\n");
my $i = 1;
my $traversed = 0;
if(!$runs) {
    $runs = 1;
}

my $traversal;
while($i <= $runs) {
    my $epoch = time();
    $traversed = 0;
    if($recurse) {
        $traversal = recursive(0);
    }
    elsif($bottomup) {
        my $j = $i;
        foreach my $e (@errors) {
            $traversal = bottomup($e);
            if($dot and $j == 1) { dotgen($traversal); }
            $i++;
        }
        $i = $j;
    }
    else {
        $traversal = iterative(0);
    }
    $epoch = time() - $epoch;
    my $teps = ($traversed / $epoch);
    print(STDERR "$i: $nacc nodes $eacc edges $teps TEPS\n");
    $i++;
}

exit(0);

#Iterative DFS
sub iterative {
    my ($v) = @_;
    my $return = "";
    my @stack;
    push(@stack, $v);
    while(scalar(@stack)) {
        my $n = pop(@stack);
        if(($nodes{$n}{'v'} != $i)) {
            $nodes{$n}{'v'} = $i;
            $return = $return . "$n:";
            $traversed++;
            my @children = split(":", $nodes{$n}{'c'}); 
            my @attrs = split(":", $nodes{$n}{'a'});
            foreach my $c (@children) {
                my @cattrs = split(":", $nodes{$c}{'a'});
                my $cf = 0;
                foreach my $ca (@cattrs) {
                    foreach my $na (@attrs) {
                        if(substr($na, 1) eq substr($ca, 1)) {
                            if($c >= 0) { push(@stack, $c); }
                            $cf = 1;
                            last;
                        }
                    }
                    if($cf) { last; }
                }
            }
        }
    }
    return $return;
}

#Bottom-up iterative DFS
sub bottomup {
    my ($v) = @_;
    my $return = "";
    my @stack;
    push(@stack, $v);
    while(scalar(@stack)) {
        my $n = pop(@stack);
        if(($nodes{$n}{'v'} != $i)) {
            $nodes{$n}{'v'} = $i;
            $return = $return . "$n:";
            $traversed++;
            my @parents = split(":", $nodes{$n}{'p'});
            my @attrs = split(":", $nodes{$n}{'a'});
            foreach my $p (@parents) {
                my @pattrs = split(":", $nodes{$p}{'a'});
                my $pf = 0;
                foreach my $pa (@pattrs) {
                    foreach my $na (@attrs) {
                        if(substr($na, 1) eq substr($pa, 1)) {
                            if($p >= 0) { push(@stack, $p); }
                            $pf = 1;
                            last;
                        }
                    }
                    if($pf) { last; }
                }
            }
        }
    }
    return $return;
}

#Recursive DFS
sub recursive {
    my ($v) = @_;
    $nodes{$v}{'v'} = $i;
    $traversed++;
    my $rc;
    my @children = split(":", $nodes{$v}{'c'});
    foreach my $c (@children) {
        if($c >= 0) { $rc = &recursive($c); }
    }
    my $return = "";
    if($rc) { $return = $return . $rc . ","; }
    $return = $return . $v;
    return $return;
}

#Calculate exponential decay
sub decay {
    my $d = 1;
    return $d;
}

sub dotgen {
    my ($path) = @_;
    my @nodes = split(":", $path);
    @nodes = sort { $a <=> $b } @nodes;
    my $file = "$input.$i.dot";
    open(DOT, ">>", $file) or die "Could not open $file for writing.\n";
    print(DOT "digraph {\n\noverlap=\"scale\";\nnode [shape=box,color=black,style=unfilled,fixedsize=false];\n\n");
    foreach my $n (@nodes) {
        if($nodes{$n}{'e'}) { print(DOT "N$n [label=\"N$n [$nodes{$n}{'a'}]\",style=filled,fillcolor=\"#d64933\"];\n"); }
        else { print(DOT "N$n [label=\"N$n [$nodes{$n}{'a'}]\",style=filled,fillcolor=\"#0c7c59\"];\n"); }
        my @children = split(":", $nodes{$n}{'c'});
        foreach my $c (@children) {
            if($c >= 0) { print(DOT "N$n -> N$c;\n"); }
        }
    }
    print(DOT "}");
    close(DOT);
    return 0;
}

sub print_help {
    print $usage;
    exit(1);
}
# vim: tabstop=8 shiftwidth=4 softtabstop=4 expandtab shiftround autoindent
